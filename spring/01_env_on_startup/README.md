# 01_env_on_startup

### Цель

Научиться работать со стандартными евентами Spring. 

### Теория

Совет перед прочтением: Большая часть классов и интерфейсов в Spring/Spring Boot содержит подробные javadoc'и. При работе
с компонентами спринга очень рекомендую скачивать исходники Spring (Idea, например, умеет делать эта сама) 
для доступа к документации и читать все что там написано. 

---

Главной частью любого Spring / Spring Boot приложения является 3 интерфейса:
 - ```org.springframework.context.ApplicationContext```
 - ```org.springframework.beans.factory.BeanFactory``` 
 - ```org.springframework.core.env.Environment```

Большая часть приложений при старте использует расширения этих интерфейсов с приставкой ```Configurable```, например
```org.springframework.context.ConfigurableApplicationContext```. 

```ApplicationContext``` является центральной частью приложения. Он содержит информацию об имени приложения, времени запуска, 
а также содержит ссылки на внутренние ```BeanFactory``` и ```Environment```, используемые приложением.

```BeanFactory``` представляет собой точку входа для доступа к компонентам приложения (бинам). 

```Environment``` - интерфейс, предоставляющий доступ ко всему окружению, в котором запущено приложение. Здесь находятся
профили, переменные среды, к которым имеет доступ приложения, а также записи в файлах конфигурации.

При старте Spring / Spring Boot приложения, сначала создается контекст, инициализируются 3 выше перечисленных интерфейса 
(а также все объекты, определенные ими. Например бины), затем приложение становится доступно для работы. Более
подробно о процессе инициализации мы поговорим в следующих выпусках :)

---

Во время процесса инициализации контекста, а также во время работы приложения, Spring дает пользователю возможность
перехватить управления для выполнения каких-то своих задач. Одним из способов такого "перехвата управления" является механизм
event'ов. 

Все спринговые event'ы публикуются классами, имплементирующими интерфейс ```ApplicationEventPublisher```. Евент публикуется
в виде класса, расширяющего абстрактный класс ```ApplicationEvent```. Следить за евентами можно при помощи классов, 
имплементирующих интерфейс ```ApplicationListener```. 

После публикации евентов, они разбрасываются листенерам при помощи ```ApplicationEventMulticaster```. Важно: поумолчанию
евенты срабатывают *синхронно* в ```SimpleApplicationEventMulticaster```. Иными словами - при вызове ```publishEvent(...)```, 
этот же самый тред исполнит код всех листенеров. Это поведение можно сделать асинхронным. Как это сделать можно почитать 
например [здесь[1]](https://www.baeldung.com/spring-events). Также возможно создание Listener'ов при помощи аннотаций.

Существует несколько стандратных для Spring и для Spring Boot евентов, которые публикуются приложением самостоятельно, и 
могут быть перехвачены пользователем при помощи создания имплементации ```ApplicationListener``` для перехвата определенного
евента. Целью нашего задания как раз таки и будет перехватить один из таких стандартных евентов.

Стандартные евенты перечислены:
- [здесь для Spring[2]](https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#context-functionality-events) 
- [здесь для Spring Boot[3]](https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-application-events-and-listeners)

Далее будет раздел на почитать, а после него - задание для выполнения.

### Почитать

1. Почитать про Event'ы в Spring https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#context-functionality-events
2. Почитать про Event'ы в SpringBoot https://docs.spring.io/spring-boot/docs/current/reference/htmlsingle/#boot-features-application-events-and-listeners
3. Почитать про синхронные/асинхронные евенты Spring https://www.baeldung.com/spring-events

### Задание

Дано Spring Boot приложение. Необходимо создать свой ```ApplicationListener```, который перехватит правильный евент 
Spring Boot на старте приложения, соберет в ```Map<String, String>``` информация о всех переменных среды, доступных приложению, и
после этого вызовет статический метод ```FileWriter.writeProps(Map<String, String> pros)``` с собранными переменными.

Для проверки работы присутствует тест в ```ru.neoflex.dev.spring.env_on_startup.EnvOnStartupTest```. Этот тест читает файл 
со строками конфигрурации из предыдущего пагарафа, и проверяет, есть ли там строка с профилем. Файл для чтения захардкожен в тесте
и в методе ```FileWriter.writeProps(Map<String, String> pros)```, поэтому дополнительная настройка не понадобится.

Note: сущестует полтора десятка способов, как обмануть тест, чтобы тест выполнялся, а евент не перехватывался. Пожалуйста, 
давайте не будем читерить :) Цель задания - перехватить евент и выполнить произвольный код, который получит прочитает переменные 
окружения.

Подсказка: В event'ы можно засовывать произвольные объекты во время их публикации, а затем вытаскивать эти объекты на 
этапе Listener'ов. В частности некоторые стандартные евенты позволяют получить доступ к  ```ConfigurableApplicationContext``` 
из которого можно вытащить ```ConfigurableEnvironment```. Этот объект, в свою очередь, содержит все необходимые данные 
для создания полного списка всех перменных окружения/конфигураций, доступных приложению.
