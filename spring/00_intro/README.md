# 00_introduction

### Цель

Понять зачем нужен Spring/Springboot. 

### Теория

#### IoC и DI
Описать один предложением, что такое Spring и зачем он нужен довольно тяжело, так как спрингу уже больше 15 лет, и за это время в нем было реализовано бесчисленное множество различного функционала. Тем неменее можно выделить основную часть фреймворка - а именно **inversion of controll (IoC)** контейнер. 
Суть принципе IoC заключается в интерватации способа работы обычной программа. Типичная программа реализует конкретный функционал за счет вызова максимально абстрактных функций/методов/кусков кода в такой же максимально абстрактной библиотеке. Т.е. главенствующую роль в исполнении произвольного кода занимает сам этот код. В случае с IoC - главенствующую роль занимает некий фреймворк, а кастомный код занимает какие-то места в этом фреймворке. Вот есть прекрасное [полутороминутное видео[1]](https://www.youtube.com/watch?v=vFzP2SaMyA0) про IoC.

Существует несколько способо реализации принципе IoC. Самым распространенным является внедрение зависимостей - Dependency Injection (DI). Суть DI в явном указании зависимостей компонентов в программе. Таким образом, компоненты DI не могут (и не должны) осуществлять свою работу, если вызывающий/создающий их компонент 
не передаст внутрь этого компонента все необходимые зависимости. Рассмотрим пример.

Ужасная жизнь без DI. Представим что мы пишет интернет-магазин. У нас будет 2 класса - собственно интернет магазин ```OnlineStore``` и хранилище с вещами этого маганиза - ```Warehouse```. Если не использовать DI, наша программа могла вы выглядеть следующим образом.
```
public class OnlineStore {

    private Warehouse warehouse;

    public OnlineStore() {
        this.warehouse = new Warehouse();
    }
}
```

Так образом, от внешнего мира скрыт факт того, что ```OnlineStore``` зависит от класса ```Warehouse```. так *можно* делать, но давайте рассмотри альтернативу.

Прекрасная жизнь с DI. Давайте явно выразим зависимость ```OnlineStore``` от ```Warehouse```.

```
public class OnlineStore {

    private final Warehouse warehouse;

    public OnlineStore(Warehouse warehouse) {
        this.warehouse = warehouse;
    }
}
```

Обратите внимание на модификатор final и на передачу ```Warehouse``` в конструктор ```OnlineStore```. Что изменилось? Теперь любой класс, который создает ```OnlineStore``` ОБЯЗАН передать в конструктор ```Warehouse```, иначе использовать класс будет невозможно. Такой подход дает несколько преимуществ.

Во-первых, становится очень просто подменять одну реализацию другой

```
public class ShirtsWarehouse extends Warehouse {

}


<somewhere deeper in your code> 

    public static void main(String[] args) {
        var shirtsStore = new OnlineStore(new ShirtsWarehouse);
    }
```

Такая замена в частности позволяет очень просто подменять реализацию на mock во время тестирования.

Во-вторых, мы получаем возможность сразу же обнаружить циклические зависимости в наших классах. Так как создание всего происходит через констуктор и внедрение зависимостей мы попросту не может создать циклические зависимости.



#### А при чем здесь Spring

### Почитать


1. Что такое IoC https://www.youtube.com/watch?v=vFzP2SaMyA0
2. 
