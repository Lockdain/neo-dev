# 03_rename_bean

### Цель

Понять, как создаютс бины во время инициализации контекста, и как можно влиять на этот процесс.

### Теория

Одним из самых главных (и самых сложны) этапов создания ```ApplicationContext``` в спринге является создания и наполнение
```BeanFactory```, а именно - создание бинов.

Бины создаются в несколько фаз, которые можно расставить в таком порядке

1. Сначала так или иначе считываются описания всех бинов (```BeanDefinition```). Раньше для этого использовался XML, 
теперь все чаще - аннотации. Бин дефинишины можно считывать даже из проперти файлов или из груви скриптов. Механизм
вполне себе кастомизируется, поэтому считывать их в теории можно практически откуда угодно  (например 
 можно посмотреть спринг-потрошитель [здесь[1]](https://www.youtube.com/watch?v=BmBr5diz8WA). Там же сравнение скорости
 инициализации контекса с XML и с аннотациями (спойлер - XML парсить быстрее).
2. Затем ```BeanFactory``` с начитанными дефинишинами обрабатывается в нескольких ```BeanFactoryPostProcessor```. 
Имплементации этих интерфейсов применяются один за другим, чтобы каким-то образом изменить ```BeanDefinition``` (Это тоже интерфейс спринга. Можно в него
перейти и почитать что это). В качестве изменений можно задавать и удалять проперти бинов, заменять один ```BeanDefinition``` на другой, добавлять
новые ```BeanDefinition```, устанавливать бины, как ```Primary``` и еще много чего. Важно: на этом этапе НЕЛЬЗЯ создавать инстансы бинов. 
Только подменять определение.
В стандартном спринге очень много разных ```BeanFactoryPostProcessor``` с длиннющими названиями, например 
```EmbeddedDataSourceBeanFactoryPostProcessor```, который подменяет реальный ```DataSource``` встроенным. 
3. Далее идет непосредственно процесс создания бина. В этом помогают ```BeanPostProcessor```. При помощи этого интерфейса можно обернуть бины
в прокси (что спринг делает для всех сервисов, например) или инициализировать неинициализированные интерфейсы. BeanPostProcessor имеет 2 метода - 
```postProcessBeforeInitialization``` и ```postProcessAfterInitialization```. А еще есть констуктор бина и ```@PostConstruct```. В итоге инициализация 
происходит следующим образом:
    1. Сначала вызывает ```postProcessBeforeInitialization```. Он вызывается на бине, которому уже проставили проперти.
    2. Затем вызывается констуктор бина
    3. Затем ```@PostConstruct``` (это же называется init-метод)
    4. После этого вызывается ```postProcessAfterInitialization```
Очень частой схемы работы ```BeanPostProcessor``` является начитывание списка бинов с некоторым маркером в ```postProcessBeforeInitialization```,
а затем создание прокси над этими бинами в ```postProcessAfterInitialization```. Более подробно можно посмотреть в спринг-потрошителе 
(ссылка есть выше).
4. После этого шага, каждый бин вызывает евент ```ContextRefreshedEvent```. Его можно перехватить и например вызвать какой-нибудь метод
только что созданного бина.

##### Когда использовать 
Обычно для хаков :)

Пример можно посмотреть [здесь[2]](https://bravenewgeek.com/a-look-at-springs-beanfactorypostprocessor/)
И конечно же в спринг-потрошителе.

Как правило, если хочется использовать перечисленные выше интерфейсы - то либо существует более простой путь, либо вы
реально знаете, что делаете. Или пишите свою библиотеку.

### Почитать

1. Спринг-потрошитель. Ощень подробно (и долго)
    1. https://www.youtube.com/watch?v=BmBr5diz8WA 
    2. https://www.youtube.com/watch?v=cou_qomYLNU
    3. https://www.youtube.com/watch?v=yy43NOreJG4
    4. https://www.youtube.com/watch?v=7Cq5zEm2wq0
2. Рассказ о том, как заставить тесты НЕ ПОДНИМАТЬ под собой tomcat, а использовать тот же tomcat, который разработчик 
 использует во время разработки https://bravenewgeek.com/a-look-at-springs-beanfactorypostprocessor/

### Задание

Есть класс ```ShapeShifter``` с проперти ```myProp ```. Он создается в конфигурации ```BeansConfig``` 
Значение проперти задается в файле ```application.property```. . Неободимо написать ```BeanFactoryPostProcessor```, 
который превратит установит ```myProp = 10```. 

NOTE: Задачу можно решить и при помощи подмена проперти, и при помощи изменение значения переменной после создания бина и даже
 вызовом сеттера после создания бина и перехватат соответствующего евента. Любой метод будет считаться правильным.
Единственное условие - код решения не должен трогать файл ```application.properties```, класс ```ShapeShifter``` и ```класс BeansConfig```

Тест должен проходить.